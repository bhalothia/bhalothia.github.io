---
layout: post
title: 'Thinking out aloud: Python decorators'
date: '2013-06-10T13:40:00.001+05:30'
author: Saurabh
tags: 
- python
modified_time: '2013-06-27T01:26:44.818+05:30'
blogger_id: tag:blogger.com,1999:blog-590496507799049344.post-3130503302675670435
blogger_orig_url: http://curiosityhealsthecat.blogspot.com/2013/06/thinking-out-aloud-python-decorators_8528.html
---

This is not yet another explanation of decorators. There are a lot of people who have done a great job of explaining it. What this post is about is the way I understood it and how I wrap my head around decorators (pun intended).  <br /><br />Pre-requisite: this awesome <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank">stackoverflow answer</a> on decorators.  <br /><br />I had been trying to learn <a href="http://flask.pocoo.org/" target="_blank">Flask</a> and came across this nice <a href="http://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask" target="_blank">post</a>.  It contains a good introduction to flask in the form of a mini project. While going through the post, I came across this snippet: <br /><br /><script src="https://gist.github.com/saurabh-hirani/5735116.js"></script> <br /><b>@app.route('/')</b> is a decorator which registers the index function to be called when a user makes GET requests to the root page.  <br /><br />I always get the part where we say that a decorator is a function which modifies another function - wraps it with a sort of pre and post functionality. The part of where decorators are passed arguments is what used to confuse me and led me to revisit the afforementioned <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank">stackoverflow post</a><br /><br />For example, it is easy to understand this:<br /><br /><script src="https://gist.github.com/saurabh-hirani/5737741.js"></script><br /><br />Output:<br /><pre style='color:black;background-color:#D3D3D3'><br /> Decorator calling func<br /> In the function<br /> Decorator called func<br /><br /></pre><br />which means that when Python encountered the <b>@</b> symbol it did an internal equivalent of <br /><pre style='color:black;background-color:#D3D3D3'>func = decorator(func)</pre><br />which in turn means that a decorator is a function which takes in a function and returns a wrapper over that function and reassigns that wrapper to the original function variable.  <br /><br />This has the side effect of redefining the function name also (<b>func.__name__</b>), to be that of the wrapper function, but as the stackoverflow answer mentions <b>functools.wraps</b> comes to the rescue.<br /><br />What used to stall me were these kind of examples:<br /><br /><script src="https://gist.github.com/saurabh-hirani/5737743.js"></script><br /><br />Output:<br /><br /><pre style='color:black;background-color:#D3D3D3'><br />  func1  args - [this, that]<br />  func2  called_from_line:31  args - [who, what]<br /><br /></pre><br />For func1 our logging is not as verobse as func2 which has 'debug' log level. This is possible because the decorator creating function takes an argument which decides logging behavior (whether to print line no. of caller or not). <br /><br />The magic of <a href="http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python" target="_blank">closures</a> is also involved because the decorator and the wrapped function remember the original environment that they were bound with (for func1 the variable loglevel is set to 'info' in wrapped_around_func and for func2, it is set to 'debug')<br /><br />But what is the deal with the nesting of functions?<br /><br /><a name='more'></a><br /><br />It's clear to get if one uses the right function names for each function in the example. Here is the modified version of the previous code snippet, with changes only in the function names:<br /><br /><script src="https://gist.github.com/saurabh-hirani/5743126.js"></script><br /><br />Output:<br /><pre style='color:black;background-color:#D3D3D3'><br />  func1  args - [this, that]<br />  func2  called_from_line:31  args - [who, what]<br /><br /></pre><br />So we call a <b>log_decorator_factory</b> which defined one or more decorators - (only 1 in this case - <b>log_decorator_1</b>). This decorator is responsible for returning the function which will wrap the decorator targets - <b>func1</b> and <b>func2</b> in this case.  <br /><br />This was the moment of clarity for me - either you can choose a decorator depending on the argument passed to the decorator factory or you can use the argument and create different sections of code within one decorator. We did the later in the previous example.<br /><br />To do the former, check out this piece of code:<br /><br /><script src="https://gist.github.com/saurabh-hirani/5743174.js"></script><br /><br />Output:<br /><pre style='color:black;background-color:#D3D3D3'><br />  func1  args - [this, that]<br />  func2  called_from_line:39  args - [who, what]<br /><br /></pre><br />The output and the decorator interface to func1 and func2 being the same, what is changing is that the factory defines 2 decorators: log_decorator_1, log_decorator_2 - and the right one is returned depending on the argument.<br /><br />This might seem to be overkill for some - defining 2 functions when creating a logical branch in one could suffice. I agree. But I find it useful to remember the concept of decorators this way.<br /><br />The way I say it in my mind:<br /><br /><p style='color:black;background-color:#D3D3D3'><br />  A decorator factory defines one or more decorators and depending on the argument passed to the decorator factory - the right decorator's wrapper function is returned.  <br /></p><br /><i>or</i><br /><p style='color:black;background-color:#D3D3D3'><br />  A decorator factory defines a single decorator and depending on the arugment, the decorator performs logical branching (if-else) and adds/removes functionality from the returned decorator wrapper function.  <br /></p><br /><br />This also goes to prove that if your decorator is not going to take an argument - there isn't a need for an explicit decorator factory - you can directly call the decorator. Case in point being:<br /><br /><script src="https://gist.github.com/saurabh-hirani/5737741.js"></script><br /><br />The above code could also have been written this way:<br /><br /><script src="https://gist.github.com/saurabh-hirani/5743232.js"></script><br /><br />yielding the same output. The only difference in the interface being that instead of doing <b>@decorator</b>, we do <b>@decorator_factory()</b> which means - invoke the factory, return a decorator wrapper and use that wrapper to wrap the original function. <br /><br />But as we are not taking any arguments for the factory to pass them on to the decorator and it's wrapper - what is the point of having a factory? Hence we do away with the <b>decorator_factory</b> level of nesting and just have  - <b>decorator</b> and <b>decorator_wrapper</b> as seen earlier. <br /><br />So that's how I see it. I hope this discussion helped you in refining your thoughts about decorators. Please feel free to share your insights and views on the same in the comment section.<br /><br />In my next post, I will take up the <b>@app.register('/')</b> chunk of code we encountered earlier and try to explain its internals.<br />
