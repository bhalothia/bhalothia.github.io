---
layout: post
title: Schwartzian transform explained
date: '2010-11-28T23:13:00.004+05:30'
author: Saurabh
tags: 
- perl
modified_time: '2010-12-14T17:40:24.915+05:30'
blogger_id: tag:blogger.com,1999:blog-590496507799049344.post-4020297635828539010
blogger_orig_url: http://curiosityhealsthecat.blogspot.com/2010/11/schwartzian-transform-explained.html
add_to_popular_list: true
---

Did you google for "explain schwartzian transform"?<br /><br />If yes, then you've come to the right place. If no, then you've come to the right place (I wouldn't want to loose out on a prospective reader now, would I?). Please read on - you will find this worth your time.<br /><br />This post aims to dissect the Schwartzian Transform, and explains it through an example. And while doing this, it shows how cool Perl is.<br /><br /><b>But what is the Schwartzian Transform?</b> - A way to efficiently sort a list of items.<br /><br /><b>Why the name?</b> - Legend has it that Randal "Merlyn" Schwartz (<a href="http://en.wikipedia.org/wiki/Randal_L._Schwartz" target="new">wiki page</a>) demonstrated a Perlish version of a Lisp idiom to speed up sorting. And since that day, every time you use the word "Schwartzian Transform", somewhere far beyond the distant seas, the Randal smiles.<br /><br /><b>How does it speed up sorting?</b> - Patience my child. The blooming of a flower is an analog process, revealing each petal gracefully unlike the open-throw-catch-roll-close process of a frog's tongue. (Yummy?)<br /><br /><b>Why do I need to know it? </b> - Because it's fun.  <br /><br /><b>Will each line be preceded by a question in the bold font?</b> - Not from now on.<br /><br />Suppose you have an array of salesman objects - @salesmen, each of which consists of the following attributes:<br /><br /><pre>1. name           # salesman name<br />2. base_salary    # base salary<br />3. n_cust_conned  # number of customers conned<br />4. comm_per_sale  # commission per sale<br /></pre><br />And the sub routine which calculates the total salary of the salesman is:<br /><br /><pre class="perl" name="code">sub get_total_sal {<br />    my ($obj) = @_;<br />    my $total_salary = $obj-&gt;{base_salary} + <br />                       $obj-&gt;{n_cust_conned} * $obj-&gt;{comm_per_sale};<br />    return $total_salary;<br />}<br /></pre><br />If you were told to sort this array based on the total salary, what would be your code snippet which does the sort?<br /><br />Without prior knowledge of the transform, maybe something like this:<br /><br /><pre class="perl" name="code">my @sorted_salesmen = sort { $a-&gt;get_total_sal() <br />                             &lt;=&gt;<br />                             $b-&gt;get_total_sal() } @salesmen;<br /></pre><br />This would do the job. But what limitation does it induce in your code?<br /><br />Think about it.<br /><br /><a name='more'></a>&nbsp;The reader thinks, muses and ponders. Birds migrate. Tectonic plates shift. Radioactive elements decay.<br /><br />The shortcoming is the  <b>get_total_sal()</b> call is made for each comparision. Why?<br /><br />Suppose you wanted to hand sort the following sample data based on the total salary code as shown above:<br /><br /><pre class="perl" name="code">my @salesmen_info = (<br />    {<br />      name          =&gt; 'sp1',    <br />      base_salary   =&gt; 1000,<br />      n_cust_conned =&gt; 2,<br />      comm_per_sale =&gt; 100<br />    },<br />    {<br />      name          =&gt; 'sp2',    <br />      base_salary   =&gt; 500,<br />      n_cust_conned =&gt; 4,<br />      comm_per_sale =&gt; 200<br />    },<br />    {<br />      name          =&gt; 'sp3',    <br />      base_salary   =&gt; 700,<br />      n_cust_conned =&gt; 3,<br />      comm_per_sale =&gt; 100<br />    },<br />);<br /></pre><br />1. Compare sp1 and sp2 - as sp1 &lt; sp2 keep them as is.  (sp1, sp2, sp3)<br /><br />2. Compare sp1 and sp3 - as sp3 &lt; sp1 swap sp3 and sp1.    (sp3, sp2, sp1)<br /><br />3. Compare sp2 and sp1 - as sp1 &lt; sp2 swap sp2 and sp1.    (sp3, sp1, sp2)<br /><br />Without consciously thinking, what was the first thing that you did with the data? - Calculate the total sal and then start the comparison, so  that you don't need to calculate total salary again and again. Remember that.<br /><br />Now let us revisit our sorting snippet, <br /><br /><pre class="perl" name="code">my @sorted_salesmen = sort { $a-&gt;get_total_sal() <br />                             &lt;=&gt;<br />                             $b-&gt;get_total_sal() } @salesmen;<br /></pre><br />Perl internally uses merge sort as of Perl 5.7 but for the sake of understanding let us assume that for the sample data, the above snippet sorts as we hand sorted it. <br /><br />Step 2: Compare sp1 and sp3 =&gt; this leads to <b>get_total_sal()</b> being called for sp1 and sp3.<br /><br />But didn't we call get_total_sal for sp1 during Step 1? Why do we need to call <b>get_total_sal()</b> again for sp1? <br /><br />A moment's silence.<br /><br />Bulbs flash, eyebrows are raised, jaws drop and you smile with your newly acquired wisdom.<br /><br />What if we had a way to store the total salary of each salesman so that the <b>sort {}</b> block does not cause the extra overhead of calling the <b>get_total_sal()</b> sub multiple times for the objects whose total salary was already calculated during an earlier comparison?<br /><br />That's exactly what the Schwartzian transform does.<br /><br />With the Schwartzian Saber you'd rewrite your sorting snippet like so:<br /><br /><pre class="perl" name="code">  my @sorted_salesmen = map  { $_-&gt;[0]}<br />                        sort { $a-&gt;[1] &lt;=&gt; $b-&gt;[1] }<br />                        map  { [$_, $_-&gt;get_total_sal()] }<br />                        @salesmen;<br /></pre><br />If you can read this, this means your brain did not explode. Congratulations. <br /><br />If the above code snippet makes perfect sense - get up, wear a stupid grin on your face, and stay smug all day long. If it doesn't make any sense - read on - your hubris is just a few sentences away.<br /><br />Let's read the snippet in a bottom up fashion. Pre-requisite - you know what map does. Read the man page <a href="http://perldoc.perl.org/functions/map.html" target="new">here</a><br /><br />1. Get each element of the salesmen array.<br /><br /><pre class="perl" name="code">@salesmen;<br /></pre><br />2. Map each element and create an array of array references, each of which contains the object as the first element and the total salary as the second element. This is the place where you record each salesman's salary one and only one time.<br /><br /><pre class="perl" name="code">  map  { [$_, $_-&gt;get_total_sal()] }<br />  @salesmen;<br /></pre><br /><br />3. Sort this array of array references where the comparator is the 2nd element of each array element - i.e. the total salary that you calculated in step 2. <br /><br /><pre class="perl" name="code">  sort { $a-&gt;[1] &lt;=&gt; $b-&gt;[1] }<br />  map  { [$_, $_-&gt;get_total_sal()] }<br />  @salesmen;<br /></pre><br />4. What does Step 3 return? - A sorted array of array references where first element is the salesman object and the 2nd element is the total salary. But what do we need? - just an array of salesman objects - the 2nd element of each array ref containing the total salary is of no use to us now. So we extract what we need via <b>map</b>:<br /><br /><pre class="perl" name="code">  my @sorted_salesmen = map  { $_-&gt;[0]}<br />                        sort { $a-&gt;[1] &lt;=&gt; $b-&gt;[1] }<br />                        map  { [$_, $_-&gt;get_total_sal()] }<br />                        @salesmen;<br /></pre><br />How many times did we call the <b>get_total_sal()</b> sub? Once per each object as compared to the previous method where in we called it once per each comparison.<br /><br />Of course, the speedup that you gain is dependent on how heavy/light your <b>get_total_sal()</b> is + the size of your input data. Use it wisely. <br /><br />Schwartz on!!
